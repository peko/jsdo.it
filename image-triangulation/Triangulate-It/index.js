// Generated by CoffeeScript 1.4.0
(function() {
  var S3, TR, Ta, Tr, alpha, b2c, c2b, clear, getTriangle, getTriangles, makeTriangle, onResize, point2color, pointToTriangle, resize, resizeTimeout, toggleAlpha, toggleStroke, triangles;

  TR = 1.0;

  Tr = TR / 2.0;

  S3 = Math.sqrt(3.0);

  Ta = TR * S3;

  window.stroke = "#888";

  triangles = {};

  clear = function() {
    console.log("clear");
    return ctx.clearRect(0, 0, cvs.width, cvs.height);
  };

  resizeTimeout = -1;

  resize = function() {
    console.log("resize");
    this.W = cvs.width = 4096;
    this.H = cvs.height = 4096;
    this.ctx = cvs.getContext("2d");
    clear();
    if (img.src === "") {
      return ctx.fillText("Drop an image onto the canvas", 10, 20);
    } else {
      return ctx.drawImage(img, 0, 0);
    }
  };

  onResize = function() {
    clearTimeout(resizeTimeout);
    return setTimeout(resize, 500);
  };

  this.cvs = $("canvas")[0];

  this.img = document.createElement("img");

  resize();

  window.rph = new Raphael(document.getElementById('cont'), W, H);

  this.bg = rph.rect(0, 0, W, H);

  bg.attr("fill", "rgba(0,0,0,0)");

  img.addEventListener("load", (function() {
    clear();
    return ctx.drawImage(img, 0, 0);
  }), false);

  window.addEventListener("dragover", (function(evt) {
    return evt.preventDefault();
  }), false);

  window.addEventListener("drop", (function(evt) {
    var file, files, reader;
    files = evt.dataTransfer.files;
    if (files.length > 0) {
      file = files[0];
      if (typeof FileReader !== "undefined" && file.type.indexOf("image") !== -1) {
        reader = new FileReader();
        reader.onload = function(evt) {
          return img.src = evt.target.result;
        };
        reader.readAsDataURL(file);
      }
    }
    return evt.preventDefault();
  }), false);

  c2b = function(p, a, b, c) {
    var ac, bc, d, pc, u, v, w;
    ac = {
      x: a.x - c.x,
      y: a.y - c.y
    };
    bc = {
      x: b.x - c.x,
      y: b.y - c.y
    };
    pc = {
      x: p.x - c.x,
      y: p.y - c.y
    };
    d = bc.y * ac.x - bc.x * ac.y;
    u = (bc.y * pc.x - bc.x * pc.y) / d;
    v = (ac.x * pc.y - ac.y * pc.x) / d;
    w = 1 - u - v;
    return {
      u: u,
      v: v,
      w: w
    };
  };

  b2c = function(u, v, a, b, c) {
    var w;
    w = 1 - u - v;
    return {
      x: a.x * u + b.x * v + c.x * w,
      y: a.y * u + b.y * v + c.y * w
    };
  };

  getTriangles = function(z, p, a, b, c, T, H) {
    var ab, bc, br, ca;
    if (T == null) {
      T = null;
    }
    if (H == null) {
      H = null;
    }
    z = z >> 1;
    if (z === 0) {
      return T;
    }
    br = c2b(p, a, b, c);
    if (br.u > 0 && br.v > 0 && br.w > 0) {
      if (T == null) {
        T = {};
      }
      if (H == null) {
        H = 0x4;
      }
      T[H] = [a, b, c];
      ab = {
        x: (a.x + b.x) / 2,
        y: (a.y + b.y) / 2
      };
      bc = {
        x: (b.x + c.x) / 2,
        y: (b.y + c.y) / 2
      };
      ca = {
        x: (c.x + a.x) / 2,
        y: (c.y + a.y) / 2
      };
      if (br.u <= 1 / 2 && br.v <= 1 / 2 && br.w <= 1 / 2) {
        this.getTriangles(z, p, ab, bc, ca, T, H << 2 | 0x0);
      }
      if (br.u > 1 / 2) {
        this.getTriangles(z, p, a, ab, ca, T, H << 2 | 0x1);
      }
      if (br.v > 1 / 2) {
        this.getTriangles(z, p, ab, b, bc, T, H << 2 | 0x2);
      }
      if (br.w > 1 / 2) {
        this.getTriangles(z, p, ca, bc, c, T, H << 2 | 0x3);
      }
    }
    return T;
  };

  getTriangle = function(p, a, b, c) {
    var T, br, cor, d, inc, u, v, w;
    br = c2b(p, a, b, c);
    u = Math.floor(br.u);
    v = Math.floor(br.v);
    w = Math.floor(br.w);
    d = (u + v + w) % 2;
    inc = !d ? 1 / 3 : 2 / 3;
    cor = b2c(u + inc, v + inc, a, b, c);
    T = !d ? [
      {
        x: cor.x + a.x,
        y: cor.y + a.y
      }, {
        x: cor.x + b.x,
        y: cor.y + b.y
      }, {
        x: cor.x + c.x,
        y: cor.y + c.y
      }
    ] : [
      {
        x: cor.x + a.x,
        y: cor.y - a.y
      }, {
        x: cor.x - b.x,
        y: cor.y - b.y
      }, {
        x: cor.x - c.x,
        y: cor.y - c.y
      }
    ];
    T.push({
      u: u + inc,
      v: v + inc,
      w: 1 - u - v - inc * 2
    });
    return T;
  };

  point2color = function(p) {
    var b, c, g, r;
    console.log(p, ctx);
    c = ctx.getImageData(p.x, p.y, 1, 1).data;
    console.log(p, c);
    r = c[0];
    g = c[1];
    b = c[2];
    console.log(r, g, b);
    return "rgba(" + r + "," + g + "," + b + ",1.0)";
  };

  makeTriangle = function(a, b, c) {
    var cl, cx, cy, tr;
    tr = rph.path("M" + a.x + " " + a.y + "L" + b.x + " " + b.y + "L" + c.x + " " + c.y + "L" + a.x + " " + a.y);
    cx = (a.x + b.x + c.x) / 3.0 | 0;
    cy = (a.y + b.y + c.y) / 3.0 | 0;
    cl = point2color({
      x: cx,
      y: cy
    });
    tr.attr("fill", point2color({
      x: cx,
      y: cy
    }));
    tr.attr("stroke", window.stroke);
    tr["data"] = {
      cx: cx,
      cy: cy,
      a: a,
      b: b,
      c: c
    };
    tr.click(function(e) {
      var d, p0, p1, p2, p3, p4, p5;
      d = this["data"];
      this.remove();
      p0 = b2c(1, 0, d.a, d.b, d.c);
      p1 = b2c(1 / 2, 1 / 2, d.a, d.b, d.c);
      p2 = b2c(0, 1, d.a, d.b, d.c);
      p3 = b2c(0, 1 / 2, d.a, d.b, d.c);
      p4 = b2c(0, 0, d.a, d.b, d.c);
      p5 = b2c(1 / 2, 0, d.a, d.b, d.c);
      makeTriangle(p0, p1, p5);
      makeTriangle(p1, p2, p3);
      makeTriangle(p3, p4, p5);
      return makeTriangle(p1, p3, p5);
    });
    return tr;
  };

  pointToTriangle = function(x, y, l) {
    var a, b, c, t, tr, z;
    if (l == null) {
      l = 9;
    }
    z = Math.pow(2, l);
    a = {
      x: 0,
      y: TR * z
    };
    b = {
      x: Ta / 2 * z,
      y: -Tr * z
    };
    c = {
      x: -Ta / 2 * z,
      y: -Tr * z
    };
    t = getTriangle({
      x: x,
      y: y
    }, a, b, c);
    return tr = makeTriangle(t[0], t[1], t[2]);
  };

  bg.click(function(e) {
    var x, y;
    e.preventDefault();
    console.log(e);
    x = e.pageX;
    y = e.pageY;
    return pointToTriangle(x, y);
  });

  $("#saveButton").on("click", function() {
    var a, blob, svgString;
    a = this;
    svgString = rph.toSVG();
    a.download = 'mySvg.svg';
    a.type = 'image/svg+xml';
    blob = new Blob([svgString], {
      "type": "image/svg+xml"
    });
    return a.href = (window.URL || webkitURL).createObjectURL(blob);
  });

  alpha = 0.9;

  toggleAlpha = function() {
    if (parseFloat($("svg").css("opacity")) < 1.0) {
      return $("svg").css("opacity", "1");
    } else {
      return $("svg").css("opacity", "0.9");
    }
  };

  toggleStroke = function() {
    console.log(stroke);
    if (window.stroke === "#888") {
      window.stroke = "none";
    } else {
      window.stroke = "#888";
    }
    return $("svg path").attr("stroke", window.stroke);
  };

  $("#alphaButton").on("click", toggleAlpha);

  $("#strokeButton").on("click", toggleStroke);

  $(window).keyup(function(e) {
    if (e.keyCode === 65) {
      toggleAlpha();
    }
    if (e.keyCode === 83) {
      return toggleStroke();
    }
  });

  $('body').on('contextmenu', function(e) {
    return false;
  });

}).call(this);
